;GNU ED CLONE FOR NORTHSTAR DISK OPERATING SYSTEM
;REFERENCES FILE 'NSDOS-PROC.ASM' FOR MANY OS CALLS AND CONSTANTS
;
;SAGE I HENDRICKS
;2023 NOV 13


;CONSTANTS
FALSE	EQU	000H	;FALSE BOOLEAN
TRUE	EQU	001H	;TRUE BOOLEAN

NULL	EQU	000H	;NULL BYTE
NULLPTR	EQU	00000H	;NULL WORD

CR	EQU	00DH	;CARTIDGE-RETURN
LF	EQU	00AH	;LINE-FEED
DEL	EQU	07FH	;DELETE/BACKSPACE
RETURN	EQU	00DH	;RETURN/ENTER
BACK	EQU	008H	;BACK-SPACE
SPACE	EQU	020H	;SPACE


;CODE PORTION
	ORG	TPA
MAIN:	CALL	INTRPTR		;START THE INTERPRETTER LOOP (EXIT WITH Q<CR>)

	;FALL THROUGH
EXIT:	CALL	DOS		;RETURN CONTROL TO DOS/EXIT
	;FALL THROUGH
	;FATAL ERROR IF REACHED, CONTINUOUS HALT TO PROTECT THE SYSTEM
HALT:	HLT			;HALT THE SYSTEM, IN THE CASE OF AN ERROR
	JMP	HALT		;CONTINUOUSLY

PUTCH:	;B=CHAR
	PUSH	D
	MVI	A,STDOUT	;SET OUTPUT DEVICE AS STDOUT
	CALL	COUT		;OUTPUT CHAR (B) TO STDOUT
	POP	D
	RET

GETCH:	;RETURN=ACC
	PUSH	D
	MVI	A,STDIN		;SET INPUT DEVICE AS STDIN
	CALL	CIN		;WAIT FOR INPUT, PLACE INPUT IN ACC REG
	POP	D
	RET

CRLF:	MVI	B,CR		;LOAD CR CHARACTER
	CALL	PUTCH		;PRINT TO STDOUT
	MVI	B,LF		;LOAD LF CHARACTER
	CALL	PUTCH		;PRINT TO STDOUT
	RET

BACKSPC:MVI	B,BACK		;LOAD BACKSPACE
	CALL	PUTCH		;MOVE BACK ONE CHAR
	MVI	B,SPACE		;LOAD SPACE
	CALL	PUTCH		;PRINT A SPACE (EMPTY)
	MVI	B,BACK		;LOAD BACKSPACE
	CALL	PUTCH		;MOVE BACK AGAIN
	RET

PRINT:	;DE=NULL TERMINATED STRING
	LDAX	D		;GET CURRENT CHAR
	CPI	NULL		;CHECK IF CHARACTER IS NULL
	RZ			;IF IT IS, WE ARE DONE, RETURN
	MOV	B,A		;OTHERWISE, PREPARE THE CHAR FOR PUTCH
	CALL	PUTCH		;PRINT CHARACTER TO STDOUT
	INX	D		;MOVE TO THE NEXT CHARACTER
	JMP	PRINT		;REPEAT UNTIL A NULL IS FOUND


GETSTR:	;DE=STRING ADDR, C=MAXLEN, RETURN=CHAR COUNT
	DCR	C		;RESERVE SPACE FOR NULL TERMINATOR
	MOV	A,C		;MOVE MAXLEN TO A
	STA	MAXLEN		;STORE IN MAXLEN

	MVI	A,0		;VALUE OF 000H
	STA	CINDEX		;STORE VALUE AT CINDEX
	;FALL THROUGH
GSLOOP:	CALL	GETCH		;GET CHARACTER
	STA	CINPUT		;STORE CHARACTER IN CINPUT

	;LDA	CINPUT		;LOAD CHARACTER FROM CINPUT
	CPI	DEL		;CHECK IF CHARACTER IS BACKSPACE
	JZ	GSDEL		;IF IT IS, REMOVE CHARACTER

	;LDA	CINPUT		;GET CHARACTER FROM CINPUT
	CPI	RETURN		;CHECK IF CHARACTER IS RETURN/ENTER
	JZ	GSRET		;IF IT IS, STOP GETTING INPUT

	LXI	H,MAXLEN	;LOAD MAXLEN ADDR IN HL
	MOV	C,M		;LOAD MAXLEN VALUE INTO C
	LDA	CINDEX		;GET INDEX FROM CINDEX
	CMP	C		;CHECK CINDEX AND MAXINDEX
	JZ	GSLOOP		;IF WE ARE AT MAX INDEX, LOOP EARLY	

	CALL	GSADD		;OTHERWISE, ADD THE CHARACTER TO STRING

	JMP	GSLOOP		;LOOP BACK UP AND GET NEXT CHARACTER
GSADD:	LDA	CINPUT		;GET CHARACTER FROM CINPUT
	STAX	D		;STORE THE CHARACTER IN THE STRING
	INX	D		;MOVE STRING ADDR TO NEXT CHAR

	LDA	CINPUT		;GET CHARACTER FROM CINPUT
	CALL	PUTCH		;PRINT THE CHARACTER TO STDOUT

	LXI	H,CINDEX	;LOAD INDEX ADDR
	MOV	A,M		;GET VALUE AT CINDEX
	INR	A		;INCREMENT INDEX
	MOV	M,A		;STORE NEW VALUE IN CINDEX

	RET
GSDEL:	LXI	H,CINDEX	;LOAD CINDEX ADDR
	MOV	A,M		;GET CINDEX VALUE
	CPI	0		;CHECK IF INDEX IS 0
	JZ	GSLOOP		;IF IT IS, DO NOTHING
	DCR	A		;OTHERWISE, DECREMENT CINDEX
	MOV	M,A		;STORE NEW VALUE BACK IN CINDEX

	DCX	D		;DECREMENT STRING ADDR

	;TELETYPE BACKSPACE (ECHO DELETED CHAR)
	;LDAX	D		;GET REMOVED CHARACTER
	;MOV	B,A		;PREPARE THE CHARACTER FOR PRINT
	;CALL	PUTCH		;PRINT IT TO STDOUT

	;TERMINAL BACKSPACE (ERASE DELETED CHAR)
	CALL	BACKSPC		;CLEAR PREVIOUS CHAR FROM SCREEN

	JMP	GSLOOP		;GET NEXT CHARACTER
GSRET:	MVI	A,NULL		;LOAD NULL CHARACTER
	STAX	D		;STORE THE CHARACTER IN STRING

	LDA	CINDEX		;GET VALUE AT CINDEX

	RET

BNOTA:	;A=BOOLEAN
	CPI	FALSE		;COMPARE A AND FALSE(0)
	JZ	BNOTAT		;IF BOOL IS FALSE, RETURN TRUE
	JMP	BNOTAF		;OTHERWISE, RETURN FALSE
BNOTAT:	MVI	A,TRUE		;SET RETURN REG (ACC) TO TRUE
	RET
BNOTAF:	MVI	A,FALSE		;SET RETURN REG (ACC) TO FALSE
	RET

PROMPT:	LXI	D,PROMPTSTR	;LOAD PROMPT STRING
	CALL	PRINT		;PRINT THE STRING

	LXI	D,COMBUFF	;LOAD COMBUFF ADDR FOR INPUT
	MVI	C,COMLEN	;LOAD MAX LENGTH
	CALL	GETSTR		;GET STRING INPUT IN COMBUFF
	STA	COMCOUNT	;STORE COMBUF CHARACTER COUNT

	CALL	CRLF		;MOVE TO NEXT LINE

	RET

ONECOM:	;RETURN=A (BOOLEAN 1 OR 0)
	LDA	COMCOUNT	;LOAD VALUE FROM COMCOUNT
	CPI	1		;CHECK IF THE VALUE IS 1
	JZ	ONECOMT		;IF ONLY 1 CHARACTER, THEN RET TRUE
	JMP	ONECOMF		;OTHERWISE, RET FALSE
ONECOMT:MVI	A,TRUE		;LOAD RETURN REG WITH TRUE
	RET
ONECOMF:MVI	A,FALSE		;LOAD RETURN REG WITH FALSE
	RET

INTRPTR:CALL	PROMPT		;PROMPT THE USER FOR A COMMAND
	;FALL THROUGH
ECHO:	LXI	D,COMBUFF	;LOAD COMBUFF STR ADDR IN DE
	CALL	PRINT		;PRINT THE STRING TO STDOUT
	CALL	CRLF		;PRINT NEW LINE AFTER THE STRING
	;FALL THROUGH
INTINIT:MVI	A,0		;LOAD VALUE OF 000H
	STA	ITERI		;SET INITIAL VALUE OF ITERI TO 000H

	LXI	D,COMBUFF	;STORE STRING BUFFER IN DE
	;FALL THROUGH
INTCHK:	LXI	H,COMCOUNT	;LOAD COMCOUNT ADDR
	MOV	C,M		;PLACE VALUE AT COMCOUNT IN C

	LDA	ITERI		;PLACE VALUE AT ITERI IN ACC

	CMP	C		;COMPARE COMCOUNT AND ITERI
	JZ	INTLEND		;IF THEY ARE EQUAL, WE ARE AT END OF STRING
	;FALL THROUGH
INTLOOP:;CHECK FOR EXIT CONDITION
	;FALL THROUGH
INTCHKQ:LDAX	D		;LOAD CURRENT CHARACTER INTO ACC
	XRI	'Q'		;BITWISE XOR ACC AND 'Q' CHAR
	CALL	BNOTA		;BOOLEAN NOT A
	MOV	C,A		;MOVE RESULT INTO REG C

	CALL	ONECOM		;CHECK IF ONLY 1 CHAR WAS GIVEN IN COMBUFF
	ANA	C		;COMBINE RESULTS OF ONECOM AND PREV CHECK
	CPI	TRUE		;CHECK IF RESULT IS TRUE
	JZ	INTEXIT		;IF BOTH ARE TRUE, EXIT THE INTERPRETER
	;FALL THROUGH
INTINR:	INX	D		;MOVE TO NEXT CHARACTER IN STRING DE

	LXI	H,ITERI		;LOAD ITERI ADDR
	MOV	A,M		;GET VALUE FROM ITERI
	INR	A		;INCREMENT VALUE
	MOV	M,A		;STORE VALUE BACK IN ITERI

	JMP	INTCHK		;LOOP TO NEXT CHARACTER
INTLEND:JMP	INTRPTR		;LOOP TO GET NEXT INPUT
INTEXIT:RET			;EXIT THE INTRPTR PROCEDURE

;DATA PORTION
PROMPTSTR:	DB	'* ',NULL

COMLEN		EQU	128	;LENGTH OF THE COMMAND BUFFER
COMCOUNT:	DB	0	;CHARACTER COUNT OF COMBUFF
COMBUFF:	DS	COMLEN	;COMMAND BUFFER

CINDEX:		DB	000H	;CHARACTER INDEX FOR GETCH
CINPUT:		DB	NULL	;INPUTTED CHARACTER
MAXLEN:		DB	000H	;MAXLEN

ITERI:		DB	000H	;GENERAL USE BYTE ITERATOR

MEM:	EQU	$	;BASE OF TRAILING UNUSED MEMORY (MUST BE LAST)
MAXM:	EQU	0DFFFH	;MAX MEM ADDRESS ALLOWED TO REFERENCE

	END
