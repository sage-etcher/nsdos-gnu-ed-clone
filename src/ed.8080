;LEAF EDITOR FOR NORTHSTAR DISK OPERATING SYSTEM
;REFERENCES FILE 'NSDOS-PROC.8080' FOR MANY OS CALLS AND CONSTANTS
;
;SAGE I HENDRICKS
;2023 NOV 14


;CONSTANTS
FALSE	EQU	00000$0000B	;FALSE BOOLEAN
TRUE	EQU	01111$1111B	;TRUE BOOLEAN

NULL	EQU	000H	;NULL BYTE
NULLPTR	EQU	00000H	;NULL WORD

LF	EQU	00AH	;LINE-FEED
CR	EQU	00DH	;CARTIDGE-RETURN
WHAT	EQU	03FH	;WHAT/QUESTION MARK
RETURN	EQU	00DH	;RETURN/ENTER
DEL	EQU	07FH	;DELETE/BACKSPACE
BACK	EQU	008H	;BACK-SPACE
SPACE	EQU	020H	;SPACE


;CODE PORTION
	ORG	TPA
	JMP	MAIN		;GOTO MAIN PROCDURE

	DB	' COPYRIGHT 2023 SAGE I. HENDRICKS '

;MAIN PROCEDURE
MAIN:	CALL	INTRPTR		;START THE INTERPRETTER LOOP (EXIT WITH Q<CR>)

	;FALL THROUGH
;EXIT PROCEDURE
EXIT:	CALL	DOS		;RETURN CONTROL TO DOS/EXIT
	;FALL THROUGH
	;FATAL ERROR IF REACHED, CONTINUOUS HALT TO PROTECT THE SYSTEM
HALT:	HLT			;HALT THE SYSTEM, IN THE CASE OF AN ERROR
	JMP	HALT		;CONTINUOUSLY

;OUTPUT CHARACTER PROCEDURE
PUTCH:	;B=CHAR
	PUSH	D
	MVI	A,STDOUT	;SET OUTPUT DEVICE AS STDOUT
	CALL	COUT		;OUTPUT CHAR (B) TO STDOUT
	POP	D
	RET

;INPUT CHARACTER PROCEDURE
GETCH:	;RETURN=ACC
	PUSH	D
	MVI	A,STDIN		;SET INPUT DEVICE AS STDIN
	CALL	CIN		;WAIT FOR INPUT, PLACE INPUT IN ACC REG
	POP	D
	RET

;NEWLINE PROCEDURE
CRLF:	
	MVI	B,CR		;LOAD CR CHARACTER
	CALL	PUTCH		;PRINT TO STDOUT
	MVI	B,LF		;LOAD LF CHARACTER
	CALL	PUTCH		;PRINT TO STDOUT
	RET

;BACKSPACE PROCEDURE
BACKSPC:
	MVI	B,BACK		;LOAD BACKSPACE
	CALL	PUTCH		;MOVE BACK ONE CHAR
	MVI	B,SPACE		;LOAD SPACE
	CALL	PUTCH		;PRINT A SPACE (EMPTY)
	MVI	B,BACK		;LOAD BACKSPACE
	CALL	PUTCH		;MOVE BACK AGAIN
	RET

;PRINT NULL TERMINATED STRING PROCEDURE
PRINT:	;DE=NULL TERMINATED STRING
	LDAX	D		;GET CURRENT CHAR
	CPI	NULL		;CHECK IF CHARACTER IS NULL
	RZ			;IF IT IS, WE ARE DONE, RETURN
	MOV	B,A		;OTHERWISE, PREPARE THE CHAR FOR PUTCH
	CALL	PUTCH		;PRINT CHARACTER TO STDOUT
	INX	D		;MOVE TO THE NEXT CHARACTER
	JMP	PRINT		;REPEAT UNTIL A NULL IS FOUND

;GET (INPUT) A NULL TERMINATED STRING W/ MAX SIZE
GETSTR:	;DE=STRING ADDR, C=MAXLEN, RETURN=CHAR COUNT
	DCR	C		;RESERVE SPACE FOR NULL TERMINATOR
	MOV	A,C		;MOVE MAXLEN TO A
	STA	MAXLEN		;STORE IN MAXLEN

	MVI	A,0		;VALUE OF 000H
	STA	CINDEX		;STORE VALUE AT CINDEX
	;FALL THROUGH
GSLOOP:	CALL	GETCH		;GET CHARACTER
	STA	CINPUT		;STORE CHARACTER IN CINPUT

	;LDA	CINPUT		;LOAD CHARACTER FROM CINPUT
	CPI	DEL		;CHECK IF CHARACTER IS BACKSPACE
	JZ	GSDEL		;IF IT IS, REMOVE CHARACTER

	;LDA	CINPUT		;GET CHARACTER FROM CINPUT
	CPI	RETURN		;CHECK IF CHARACTER IS RETURN/ENTER
	JZ	GSRET		;IF IT IS, STOP GETTING INPUT

	LXI	H,MAXLEN	;LOAD MAXLEN ADDR IN HL
	MOV	C,M		;LOAD MAXLEN VALUE INTO C
	LDA	CINDEX		;GET INDEX FROM CINDEX
	CMP	C		;CHECK CINDEX AND MAXINDEX
	JZ	GSLOOP		;IF WE ARE AT MAX INDEX, LOOP EARLY	

	JMP	GSADD		;OTHERWISE, ADD THE CHAR TO THE STR, AND LOOP
GSADD:	LDA	CINPUT		;GET CHARACTER FROM CINPUT
	STAX	D		;STORE THE CHARACTER IN THE STRING
	INX	D		;MOVE STRING ADDR TO NEXT CHAR

	;IF CHARACTER ISN'T PRINTED WHEN GETCH IS CALLED, PRINT IT NOW
	;LDA	CINPUT		;GET CHARACTER FROM CINPUT
	;MOV	B,A		;PREPARE THE CHARACTER TO BE PRINTED
	;CALL	PUTCH		;PRINT THE CHARACTER TO STDOUT

	LXI	H,CINDEX	;LOAD INDEX ADDR
	MOV	A,M		;GET VALUE AT CINDEX
	INR	A		;INCREMENT INDEX
	MOV	M,A		;STORE NEW VALUE IN CINDEX

	JMP	GSLOOP
GSDEL:	LXI	H,CINDEX	;LOAD CINDEX ADDR
	MOV	A,M		;GET CINDEX VALUE
	CPI	0		;MAKE SURE THERE ARE CHARACTS IN THE BUFFER
	JZ	GSLOOP		;IF THERE AINT, DONT DO NOTHING
	DCR	A		;OTHERWISE, DECREMENT CINDEX
	MOV	M,A		;STORE NEW VALUE BACK IN CINDEX

	DCX	D		;DECREMENT STRING ADDR

	;TELETYPE BACKSPACE (ECHO DELETED CHAR)
	;LDAX	D		;GET REMOVED CHARACTER
	;MOV	B,A		;PREPARE THE CHARACTER FOR PRINT
	;CALL	PUTCH		;PRINT IT TO STDOUT

	;TERMINAL BACKSPACE (ERASE DELETED CHAR)
	CALL	BACKSPC		;CLEAR PREVIOUS CHAR FROM SCREEN

	JMP	GSLOOP		;GET NEXT CHARACTER
GSRET:	MVI	A,NULL		;LOAD NULL CHARACTER
	STAX	D		;STORE THE CHARACTER IN STRING

	LDA	CINDEX		;GET VALUE AT CINDEX

	RET

;INTERPRETER PROMPT PROCEDURE, PRINT PROMPT, THEN GET STRING
PROMPT:	LXI	D,PROMPTSTR	;LOAD PROMPT STRING
	CALL	PRINT		;PRINT THE STRING

	LXI	D,COMBUFF	;LOAD COMBUFF ADDR FOR INPUT
	MVI	C,COMLEN	;LOAD MAX LENGTH
	CALL	GETSTR		;GET STRING INPUT IN COMBUFF
	STA	COMCOUNT	;STORE COMBUF CHARACTER COUNT

	CALL	CRLF		;MOVE TO NEXT LINE

	RET

;RETURNS TRUE IF ONLY 1 INSTRUCTION IS IN COMBUFF OTHERWISE FALSE
ONECOM:	;RETURN=A (BOOLEAN 1 OR 0)
	LDA	COMCOUNT	;LOAD VALUE FROM COMCOUNT
	CPI	1		;CHECK IF ONLY 1 CHARACTER WAS INPUT
	JZ	ONECOMT		;IF THERE IS ONLY ONE, THEN RET TRUE
	;JMP	ONECOMF		;OTHERWISE, RET FALSE
	;FALL THROUGH
ONECOMF:MVI	A,FALSE		;LOAD RETURN REG WITH FALSE
	RET
ONECOMT:MVI	A,TRUE		;LOAD RETURN REG WITH TRUE
	RET

;CONVERTS CHARACTER TO UPPER CASE
TOUPPER:;E=CHAR IN, RETURN=ACC
	MOV	A,E
	SBI	'a'		;SUBTRACT LOWERBOUND FROM ACC
	JC	TUPPRF		;CARRY IS SET IF ACC < LOWER BOUND
	
	MVI	A,'z'		;LOAD UPPER BOUNDS INTO ACC
	SUB	E		;SUBTRACT CHAR FROM UPPER BOUND
	JC	TUPPRF		;CARRY IS SET IF ACC > UPPER BOUND
	;FALL THROUGH
TUPPRS:	;TOUPPER SUCCESS
	MOV	A,E		;MOVE THE CHARACTER BACK INTO ACC
	SUI	'A'-'a'		;CONVERT CHARACTER USING OFFSET
	RET
TUPPRF:	;TOUPPER FAIL
	MOV	A,E		;RETURN THE ORIGONAL CHARACTER
	RET

;CHECKS IF ACC IS A DIGIT CHARACTER 0-9
ISDIGIT:;E=CHAR IN, RETURN ACC
	MOV	A,E
	SUI	'0'		;SUBTRACT LOWERBOUND FROM ACC
	JC	ISNTDIG		;CARRY IS SET IF ACC < LOWER BOUND
	
	MVI	A,'9'		;LOAD UPPER BOUNDS INTO ACC
	SUB	E		;SUBTRACT CHAR FROM UPPER BOUND
	JC	ISNTDIG		;CARRY IS SET IF ACC > UPPER BOUND
	;FALL THROUGH
ISDIG:	;IS A DIGIT (SUCCESS)
	MOV	A,TRUE		;RETURN TRUE
	RET
ISNTDIG:;IS NOT A DIGIT (FAIL)
	MVI	A,FALSE		;RETURN FALSE
	RET

;COMMAND READ FILE
CREAD:
	JMP	ILEND		;GET NEXT PROMPT, IGNORE TRAILING CHARS

;COMMAND WRITE FILE
CWRITE:
	JMP	ILEND		;GET NEXT PROMPT, IGNORE TRAILING CHARS

;COMMAND MOVE LINE
CMVLINE:
	JMP	ILCHECK		;GET NEXT COMMAND

;COMMAND MOVE CHAR
CMVCHAR:
	JMP	ILCHECK		;GET NEXT COMMAND

;COMMAND PRINT PAGE
CPAGE:
	JMP	ILCHECK		;GET NEXT COMMAND

;COMMAND INSERT PROC
CINSERT:
	JMP	ILEND		;GET NEXT PROMPT, IGNORE TRAILING CHARS

;CALCULATE COMPTR
CCOMPTR:LXI	H,COMBUFF	;LOAD ADDRESS OF COMBUFF IN HL
	STA	ITERI		;LOAD VALUE OF ITERI
	MOV	E,A		;SET DE(LB) TO (ITERI)
	MOV	D,000H		;SET DE(HB) TO 000H
	DAD	D		;ADD ITERI OFFSET TO COMBUFF
	SHLD	COMPTR		;STORE RESULTING ADDRESS IN COMPTR
	RET

;INREMENT ITERI
INCCIT:	LXI	H,ITERI		;LOAD ITERI ADDRESS
	MOV	A,M		;GET VALUE AT ITERI
	INR	A		;INCRMENT TO NEXT VALUE
	MOV	M,A		;STORE NEW VALUE IN ITERI
	RET

;MOVE COMPTR AND ITERI TO THE NEXT CHARACTER
NXTCHAR:CALL	CCOMPTR		;CALCULATE COMPTR
	CALL	INCCIT		;INCREMENT COMPTR
	RET

;CONVERT ASCII CHAR TO DIGIT
TODIGIT:;E=CHAR IN, RETURN=ACC
	MOV	A,E		;MOVE THE CHARACTER INTO A
	SUB	'0'		;REMOVE OFFSET
	RET

;LEFT ROTATE WORD 1 BIT
WORDROL:;HL=IN AND OUT
WROLL:	MOV	A,L		;LOAD LOW ORDER BYTE IN ACC
	MOV	F,0		;APPEND 0 TO THE RIGHT SIDE
	RAL			;ROTATE BY 1 BIT
	MOV	C,F		;SAVE FLAGS IN C
	MOV	L,A		;STORE LOW ORDER BYTE BACK IN L
	MOV	A,H		;LOAD HIGH ORDER BYTE IN ACC
	MOV	F,C		;RESTORE FLAGS FROM LOW ORDER ROTATE
	RAL			;ROTATE BY 1 BIT
	MOV	H,A		;STORE HIGH ORDER BYTE BACK IN H
	RET

;ROTATE HL BY C
WROL:	;HL=WORD, C=COUNT
	MOV	A,C		;LOAD COUNTER INTO ACC
	CPI	0		;CHECK IF COUNTER IS 0
	RZ			;IF IT IS, RETURN
	PUSH	C		;OTHERWISE, STORE THE COUNTER
	CALL	WORDROL		;AND ROTATE HL BY 1 BIT
	POP	C		;THE RESTORE THE THE COUNTER
	DCR	C		;AND DECRIMENT IT BY 1
	JMP	WROL		;THEN LOOP BACK TO START

;MULTIPLY HL BY 10
WXTEN:	;HL=WORD
	SHLD	WTTEN		;SAVE HL IN WTTEN
	MVI	C,3		;WROL PARAM COUNT OF 3
	CALL	WROL		;BITSHIFT HL << 3
	XCHG			;SAVE ROTATED HL IN DE
	PUSH	D		;STORE SAVED DE
	LHLD	WTTEN		;LOAD ORIGONAL WORD INTO HL
	MVI	C,1		;WROL PARAM COUNT OF 1
	CALL	WROL		;BITSHIFT HL << 1
	POP	D		;RESTORE FIRST BITSHIFT RESULT
	DAD	D		;ADDED 2 BITSHIFT RESULTS
	RET

;GET 16 BIT NUMBER FROM COMBUF
GETNUM:	;RETURN=HL
	LXI	H,00000H	;LOAD HL WITH (WORD)0	
GNLOOP:	CALL	WXTEN		;MULTIPLY HL BY 10
	PUSH	H		;STORE RESULT
	LHLD	COMPTR		;GET CHAR PTR IN HL
	MOV	E,M		;GET CHARACTER IN E
	CALL	TODIGIT		;CONVERT CHARACTER TO DIGIT
	MOV	E,A		;MOVE DIGIT TO LOW ORDER BYTE OF DE
	MVI	D,000H		;BLANK HIGH ORDER BYTE OF DE
	POP	H		;RESTORE RESULT COUNTER
	DAD	D		;ADD NEW DIGIT
GNCHECK:PUSH	H		;STORE RESULT
	LHLD	COMPTR		;GET CHARACTER ADDR
	INX	H		;MOVE TO NEXT DIGIT TO CHECK
	MOV	E,M		;LOAD CHARACTER INTO E
	CALL	ISDIGIT		;CHECK IF CHARACTER IS A DIGIT
	POP	H		;RESTORE RESULT
	CPI	FALSE		;SET Z FLAG IF CHAR IS NOT A DIGIT
	RZ			;IF IT ISN'T A DIGIT, RETURN
	PUSH	H		;STORE RESULT
	CALL	NXTCHAR		;OTHERWISE, MOVE TO NEXT CHARACTER
	POP	H		;RESTORE RESULT
	JMP	GNLOOP		;IF CHAR IS A DIGIT, UPDATE RESULT

;READ COMBUFF TO TELL IF NUMBER IS ABSOLUTE OR RELATIVE DISTANCE
ISABS:	;RETURN=ACC
	LHLD	COMPTR		;LOAD CURRENT CHAR ADDR INTO HL
	INX	H		;MOVE TO NEXT CHARACTER
	MOV	A,M		;LOAD CHARACTER INTO ACC
	CPI	':'		;CHECK CHARACTER AGAINST ABS SPECIFIER
	JZ	ISABST		;IF CHARACTER MATCHES, RETURN TRUE
	;JMP	ISABSF		;OTHERWISE RETURN FALSE
	;FALL THROUGH
ISABSF:	MVI	A,FALSE		;LOAD FALSE RETURN
	RET
ISABST:	CALL	NXTCHAR		;MOVE TO NEXT CHARACTER
	MVI	A,TRUE		;LOAD TRUE RETURN
	RET

;GET DIRECTION
GETDIR:	;CHECK FOR DIRECTION SPECIFIER
	LHLD	COMPTR		;LOAD CURRENT CHAR ADDR INTO HL
	MOV	A,M		;LOAD FROM ADDRESS INTO ACC
	CPI	'-'		;CHECK IF THE CHARACTER IS A MINUS
	JZ	DIRMIN		;SET DIRECTION TO BACKWARD AND INC COMPTR
	CPI	'+'		;CHECK IF THE CHARACTER IS A PLUS
	JZ	DIRPLUS		;SET DIRECTION TO FOREWARD AND INC COMPTR
	JMP	DIRFORE		;SET DIRECTION TO FOREWARDS
DIRPLUS:CALL	NXTCHAR		;INCREMENT COMPTR AND ITERI
	;FALL THROUGH
DIRFORE:MVI	A,FORWARD	;LOAD FORWARD DIRECTION CODE
	STA	DIRECTION	;STORE CODE INTO DIRECTION
	RET
DIRMIN:	CALL	NXTCHAR		;INCREMENT COMPTR AND ITERI
	;FALL THROUGH
DIRBACK:MVI	A,BACKWARD	;LOAD BACKWARD DIRECTION CODE
	STA	DIRECTION	;STORE CODE INTO DIRECTINO
	RET

;GET DISTANCE
GETDIST:;CHECK FOR PRECEEDING DISTANCE SPECIFIER
	LHLD	COMPTR		;LOAD COMPTR VALUE INTO HL
	MOV	E,M		;GET CHARACTER AT NEW ADDRESS (NEXT CHAR)
	CALL	ISDIGIT		;ACC=TRUE IF IS THE CHARACTER A DIGIT
	CPI	FALSE		;CHECK THAT THE CHARACTER IS NOT A DIGIT
	JZ	DSTDFLT		;AND IF IT ISN'T, SET DEFAULT VALUE

	CALL	GETNUM		;GET 16 BIT NUMBER FROM COMBUFF TO HL
	
	PUSH	H		;PROTECT THE VALUE IN THE HL REGISTER
	CALL	ISABS		;ACC=TRUE IF DISTANCE IS ABSOLUTE, NOT REL
	POP	H		;RESTORE THE DISTANCE NUMBER
	CPI	TRUE		;CHECK IF THE DISTANCE IS ABSOLUTE
	JZ	SETABS		;SET HL AS ABSOLUTE DISTANCE
	;JMP	SETREL		;SET HL AS RELATIVE DISTANCE
	;FALL THROUGH
SETREL:	SHLD	RELDIST		;STORE HL IN RELDIST
	CALL	NXTCHAR		;MOVE TO NEXT CHARACTER
	RET	
SETABS:	SHLD	DISTANCE	;STORE HL IN DISTANCE
	LXI	H,00000H	;STORE (WORD)0 IN HL
	JMP	SETREL		;STORE 0 AS RELATIVE DISTANCE
	
DSTDFLT:;DEFAULT DISTANCE
	LXI	H,00001H	;LOAD DEFAULT RELDISTANCE (0001)
	SHLD	RELDIST		;STORE DEFAULT INTO RELDIST
	RET

;MAIN INTERPRETER PROCEDURE
INTRPTR:;GET NEW STRING
	CALL	PROMPT		;PROMPT THE USER FOR A COMMAND
	;FALL THROUGH
IECHO:	;LXI	D,COMBUFF	;LOAD COMBUFF STR ADDR IN DE
	;CALL	PRINT		;PRINT THE STRING TO STDOUT
	;CALL	CRLF		;PRINT NEW LINE AFTER THE STRING
	;FALL THROUGH
IINIT:	;INITIATE THE LOOP OVER CHARACTRES IN COMBUFF
	MVI	A,0		;LOAD VALUE OF 000H
	STA	ITERI		;SET INITIAL VALUE OF ITERI TO 000H

	LXI	H,COMBUFF	;LOAD ADDRESS OF COMBUFF IN HL
	SHLD	COMPTR		;STORE COMBUFF ADDR IN COMPTR

	;FALL THROUGH
ILCHECK:;CHECK IF WE ARE AT THE END OF THE STRING
	LXI	H,COMCOUNT	;LOAD COMCOUNT ADDR
	MOV	C,M		;PLACE VALUE AT COMCOUNT IN C
	LDA	ITERI		;PLACE VALUE AT ITERI IN ACC
	CMP	C		;COMPARE COMCOUNT AND ITERI
	JZ	ILEND		;IF THEY ARE EQUAL, WE ARE AT END OF STRING
	;FALL THROUGH
ILOOP:	;CHECK FOR COMMANDS AND STUFF
	CALL	NXTCHAR		;GET CHARCTER PTR AND INCREMENT ITERI

	;FALL THROUGH
ICONE:	;CHECK FOR COMMANDS THAT MUST BE SINGLULAR
	CALL	ONECOM		;ACC=TRUE IF SINGLE COMMAND IN COMBUFF
	CPI	TRUE		;CHECK THAT ACC IS TRUE
	JNZ	ICMANY		;SKIP SECTION IF MORE THAN ONE COMMAND

	;GET CURRENT CHARACTER
	LHLD	COMPTR		;LOAD CURRENT CHAR ADDR INTO HL
	MOV	E,M		;GET CHARACTER READY FOR CONVERSION
	CALL	TOUPPER		;CONVERT CHARACTER TO UPPERCASE PUT IN ACC
	
	;CHECK FOR THE 'Q' COMMAND (QUIT)
	CPI	'Q'		;CHECK IF THE CHARACTER IS A 'Q'
	JZ	IEXIT		;IF IT IS EXIT THE INTERPRETER

	;FALL THROUGH	
ICMANY:
	;FALL THROUGH
ICNONE:	;CHECK FOR COMMANDS THAT NEED NEITHER DIRECTION NOR DISTANCE
	
	;GET CURRENT CHARACTER
	LHLD	COMPTR		;LOAD CURRENT CHAR ADDR INTO HL
	MOV	E,M		;GET CHARACTER READY FOR CONVERSION
	CALL	TOUPPER		;CONVERT CHARACTER TO UPPERCASE PUT IN ACC
	
	;CHECK FOR THE 'R' COMMAND (READ FILE)
	CPI	'R'		;CHECK ACC AGAINST CHAR 'R'
	JZ	CREAD		;IF THEY MATCH, GOTO THE READ FILE PROC

	;CHECK FOR THE 'W' COMMAND (WRITE FILE)
	CPI	'W'		;CHECK ACC AGAINST CHAR 'W'
	JZ	CWRITE		;IF THEY MATCH, GOTO THE WRITE FILE PROC

	;FALL THROUGH
ICNUM:	;CHECK FOR COMMANDS THE NEED BOTH DISTANCE AND DIRECTION
	CALL	GETDIR		;GET DIRECTION
	CALL	GETDIST		;GET DIRECTION

	;GET CURRENT CHARACTER
	LHLD	COMPTR		;LOAD CURRENT CHAR ADDR INTO HL
	MOV	E,M		;GET CHARACTER READY FOR CONVERSION
	CALL	TOUPPER		;CONVERT CHARACTER TO UPPERCASE PUT IN ACC

	;CHECK FOR THE 'L' COMMAND (MOVE LINE)
	CPI	'L'		;CHECK ACC AGAINST CHAR 'L'
	JZ	CMVLINE		;IF THEY MATCH, GOTO THE MOVE LINE PROC

	;CHECK FOR THE 'C' COMMAND (MOVE CHAR)
	CPI	'C'		;CHECK ACC AGAINST CHAR 'C'
	JZ	CMVCHAR		;IF THEY MATCH, GOTO THE MOVE CHAR PROC

	;CHECK FOR THE 'P' COMMAND (PRINT PAGE)
	CPI	'P'		;CHECK ACC AGAINST CHAR 'P'
	JZ	CPAGE		;IF THEY MATCH, GOTO THE PRINT PAGE PROC

	;CHECK FOR THE 'I' COMMAND (INSERT)
	CPI	'I'		;CHECK ACC AGAINST CHAR 'P'
	JZ	CINSERT		;IF THEY MATCH, GOTO THE INSERT PROC

	;UNRECOGNIZED COMMAND
	CALL	ERRWHAT		;PRINT WHAT ERROR MESSAGE
	;UNKNOWN COMMAND IN STRING, ABORT CURRENT COMBUF, GET NEW
	;FALL THROUGH
ILEND:	;GOT ALL CHARACTERS FROM STRING, GET NEXT STRING
	JMP	INTRPTR		;LOOP TO GET NEXT INPUT
IEXIT:	;EXIT INTERPRETER PROCEDURE
	RET			;EXIT THE INTRPTR PROCEDURE

;ERROR WHAT?! (UNRECOGNIZED INSTRUCTION)
ERRWHAT:MVI	B,WHAT		;LOAD WHAT ASCII CODE
	CALL	PUTCH		;PRINT THE CHARACTER
	CALL	CRLF		;MOVE TO THE NEXT LINE
	RET	

;DATA PORTION
PROMPTSTR:	DB	'* ',NULL

FNLEN		EQU	13	;FILENAME LENGTH "[8name][1.][3ext][1/0]"
FILENAME:	DS	FNLEN	;ACTIVE FILE NAME

COMLEN		EQU	128	;LENGTH OF THE COMMAND BUFFER
COMCOUNT:	DB	0	;CHARACTER COUNT OF COMBUFF
COMBUFF:	DS	COMLEN	;COMMAND BUFFER
COMPTR:		DW	COMBUFF	;COMBUFF CHARACTER PTR

CINDEX:		DB	000H	;CHARACTER INDEX FOR GETCH
CINPUT:		DB	NULL	;INPUTTED CHARACTER
MAXLEN:		DB	000H	;MAXLEN

ITERI:		DB	000H	;GENERAL USE BYTE ITERATOR

FORWARD		EQU	0	;DIRECTION FORWARD (DEFAULT)
BACKWARD	EQU	1	;DIRECTION BACKWARDS
DIRECTION:	DB	FORWARD	;DIRECTION SPECIFIER

BASELINE:	DW	NULLPTR	;CURRENT LINE IN FILE
DISTANCE:	DW	NULLPTR	;ABSOLUTE DISTANCE
RELDIST:	DW	NULLPTR	;RELATIVE DISTANCE

WTTEN		DW	NULLPTR	;TEMPORARY WORD VAR FOR WXTEN

MEM	EQU	$	;BASE OF TRAILING UNUSED MEMORY (MUST BE LAST)
MAXM	EQU	0DFFFH	;MAX MEM ADDRESS ALLOWED TO REFERENCE

	END
