;NSDOS GET STRING INPUT PROCEDURE
;
;SAGE I HENDRICKS
;2023 NOV 14


;CONSTANTS
TPA	EQU	00000H		;TRANSIENT PROGRAM AREA

NSBASE	EQU	0F700H		;BASE OF NSGDOS PROCEDURES
COUT	EQU	NSBASE+0010DH	;CHARACTER OUTPUT 
CIN	EQU	NSBASE+00110H	;CHARACTER INPUT
DOS	EQU	NSBASE+00128H	;DOS ENTRY-POINT

CON0	EQU	000H		;CONSOLE DEVICE ID

NULL	EQU	000H	;NULL BYTE
RETURN	EQU	00DH	;RETURN/ENTER
DEL	EQU	07FH	;DELETE/BACKSPACE
BACK	EQU	008H	;BACK-SPACE
SPACE	EQU	020H	;SPACE


;CODE PORTION
	ORG	TPA
	JMP	MAIN		;GOTO MAIN PROCDURE

	DB	' COPYRIGHT 2023 SAGE I. HENDRICKS '

MAIN:	LXI	D,COMBUFF	;GETSTR PARAM STRING
	MVI	C,COMLEN	;GETSTR PARAM STRING LEN
	CALL	GETSTR		;GET A STRING OF INPUT AND SAVE IT IN COMBUFF

	;FALL THROUGH
EXIT:	CALL	DOS		;RETURN CONTROL TO DOS/EXIT
	;FALL THROUGH
	;FATAL ERROR IF REACHED, CONTINUOUS HALT TO PROTECT THE SYSTEM
HALT:	HLT			;HALT THE SYSTEM, IN THE CASE OF AN ERROR
	JMP	HALT		;CONTINUOUSLY

PUTCH:	;B=CHAR
	PUSH	D
	MVI	A,CON0		;SET OUTPUT DEVICE AS CON0
	CALL	COUT		;OUTPUT CHAR (B) TO CON0
	POP	D
	RET

GETCH:	;RETURN=ACC
	PUSH	D
	MVI	A,CON0		;SET INPUT DEVICE AS CON0
	CALL	CIN		;WAIT FOR INPUT, PLACE INPUT IN ACC REG
	POP	D
	RET

BACKSPC:
	MVI	B,BACK		;LOAD BACKSPACE
	CALL	PUTCH		;MOVE BACK ONE CHAR
	MVI	B,SPACE		;LOAD SPACE
	CALL	PUTCH		;PRINT A SPACE (EMPTY)
	MVI	B,BACK		;LOAD BACKSPACE
	CALL	PUTCH		;MOVE BACK AGAIN
	RET

GETSTR:	;DE=STRING ADDR, C=MAXLEN, RETURN=CHAR COUNT
	DCR	C		;RESERVE SPACE FOR NULL TERMINATOR
	MOV	A,C		;MOVE MAXLEN TO A
	STA	MAXLEN		;STORE IN MAXLEN

	MVI	A,0		;VALUE OF 000H
	STA	CINDEX		;STORE VALUE AT CINDEX
	;FALL THROUGH
GSLOOP:	CALL	GETCH		;GET CHARACTER
	STA	CINPUT		;STORE CHARACTER IN CINPUT

	;LDA	CINPUT		;LOAD CHARACTER FROM CINPUT
	CPI	DEL		;CHECK IF CHARACTER IS BACKSPACE
	JZ	GSDEL		;IF IT IS, REMOVE CHARACTER

	;LDA	CINPUT		;GET CHARACTER FROM CINPUT
	CPI	RETURN		;CHECK IF CHARACTER IS RETURN/ENTER
	JZ	GSRET		;IF IT IS, STOP GETTING INPUT

	LXI	H,MAXLEN	;LOAD MAXLEN ADDR IN HL
	MOV	C,M		;LOAD MAXLEN VALUE INTO C
	LDA	CINDEX		;GET INDEX FROM CINDEX
	CMP	C		;CHECK CINDEX AND MAXINDEX
	JZ	GSLOOP		;IF WE ARE AT MAX INDEX, LOOP EARLY	

	JMP	GSADD		;OTHERWISE, ADD THE CHAR TO THE STR, AND LOOP
GSADD:	LDA	CINPUT		;GET CHARACTER FROM CINPUT
	STAX	D		;STORE THE CHARACTER IN THE STRING
	INX	D		;MOVE STRING ADDR TO NEXT CHAR

	LDA	CINPUT		;GET CHARACTER FROM CINPUT
	MOV	B,A		;PREPARE THE CHARACTER FOR PUTCH
	CALL	PUTCH		;PRINT THE CHARACTER TO CON0

	LXI	H,CINDEX	;LOAD INDEX ADDR
	MOV	A,M		;GET VALUE AT CINDEX
	INR	A		;INCREMENT INDEX
	MOV	M,A		;STORE NEW VALUE IN CINDEX

	JMP	GSLOOP
GSDEL:	LXI	H,CINDEX	;LOAD CINDEX ADDR
	MOV	A,M		;GET CINDEX VALUE
	CPI	0		;MAKE SURE THAT THERE ARE CHARACTERS TO DEL
	JZ	GSLOOP		;IF IT IS, DO NOTHING
	DCR	A		;OTHERWISE, DECREMENT CINDEX
	MOV	M,A		;STORE NEW VALUE BACK IN CINDEX

	DCX	D		;DECREMENT STRING ADDR

	;TELETYPE BACKSPACE (ECHO DELETED CHAR)
	;LDAX	D		;GET REMOVED CHARACTER
	;MOV	B,A		;PREPARE THE CHARACTER FOR PRINT
	;CALL	PUTCH		;PRINT IT TO CON0

	;TERMINAL BACKSPACE (ERASE DELETED CHAR)
	CALL	BACKSPC		;CLEAR PREVIOUS CHAR FROM SCREEN

	JMP	GSLOOP		;GET NEXT CHARACTER
GSRET:	MVI	A,NULL		;LOAD NULL CHARACTER
	STAX	D		;STORE THE CHARACTER IN STRING

	LDA	CINDEX		;GET VALUE AT CINDEX

	RET

;DATA PORTION
COMLEN		EQU	128	;LENGTH OF THE COMMAND BUFFER
COMBUFF:	DB	COMLEN	;COMMAND BUFFER

CINDEX:		DB	0	;GETCH CHARACTER INDEX
CINPUT:		DB	NULL	;GETCH TEMPORARY CHAR STORAGE
MAXLEN:		DB	0	;GETCH MAX STRING SIZE

	END

